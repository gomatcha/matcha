// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: github.com/gomatcha/matcha/proto/text/text.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "github.com/gomatcha/matcha/proto/text/Text.pbobjc.h"
#import "github.com/gomatcha/matcha/proto/layout/Layout.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MatchaPBTextRoot

@implementation MatchaPBTextRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MatchaPBTextRoot_FileDescriptor

static GPBFileDescriptor *MatchaPBTextRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"matcha.text"
                                                 objcPrefix:@"MatchaPB"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum MatchaPBTextAlignment

GPBEnumDescriptor *MatchaPBTextAlignment_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TextAlignmentLeft\000TextAlignmentRight\000Tex"
        "tAlignmentCenter\000TextAlignmentJustified\000";
    static const int32_t values[] = {
        MatchaPBTextAlignment_TextAlignmentLeft,
        MatchaPBTextAlignment_TextAlignmentRight,
        MatchaPBTextAlignment_TextAlignmentCenter,
        MatchaPBTextAlignment_TextAlignmentJustified,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MatchaPBTextAlignment)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MatchaPBTextAlignment_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MatchaPBTextAlignment_IsValidValue(int32_t value__) {
  switch (value__) {
    case MatchaPBTextAlignment_TextAlignmentLeft:
    case MatchaPBTextAlignment_TextAlignmentRight:
    case MatchaPBTextAlignment_TextAlignmentCenter:
    case MatchaPBTextAlignment_TextAlignmentJustified:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MatchaPBStrikethroughStyle

GPBEnumDescriptor *MatchaPBStrikethroughStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StrikethroughStyleNone\000StrikethroughStyl"
        "eSingle\000StrikethroughStyleDouble\000Striket"
        "hroughStyleThick\000StrikethroughStyleDotte"
        "d\000StrikethroughStyleDashed\000";
    static const int32_t values[] = {
        MatchaPBStrikethroughStyle_StrikethroughStyleNone,
        MatchaPBStrikethroughStyle_StrikethroughStyleSingle,
        MatchaPBStrikethroughStyle_StrikethroughStyleDouble,
        MatchaPBStrikethroughStyle_StrikethroughStyleThick,
        MatchaPBStrikethroughStyle_StrikethroughStyleDotted,
        MatchaPBStrikethroughStyle_StrikethroughStyleDashed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MatchaPBStrikethroughStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MatchaPBStrikethroughStyle_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MatchaPBStrikethroughStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case MatchaPBStrikethroughStyle_StrikethroughStyleNone:
    case MatchaPBStrikethroughStyle_StrikethroughStyleSingle:
    case MatchaPBStrikethroughStyle_StrikethroughStyleDouble:
    case MatchaPBStrikethroughStyle_StrikethroughStyleThick:
    case MatchaPBStrikethroughStyle_StrikethroughStyleDotted:
    case MatchaPBStrikethroughStyle_StrikethroughStyleDashed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MatchaPBUnderlineStyle

GPBEnumDescriptor *MatchaPBUnderlineStyle_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UndrelineStyleNone\000UndrelineStyleSingle\000"
        "UndrelineStyleDouble\000UndrelineStyleThick"
        "\000UndrelineStyleDotted\000UndrelineStyleDash"
        "ed\000";
    static const int32_t values[] = {
        MatchaPBUnderlineStyle_UndrelineStyleNone,
        MatchaPBUnderlineStyle_UndrelineStyleSingle,
        MatchaPBUnderlineStyle_UndrelineStyleDouble,
        MatchaPBUnderlineStyle_UndrelineStyleThick,
        MatchaPBUnderlineStyle_UndrelineStyleDotted,
        MatchaPBUnderlineStyle_UndrelineStyleDashed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MatchaPBUnderlineStyle)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MatchaPBUnderlineStyle_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MatchaPBUnderlineStyle_IsValidValue(int32_t value__) {
  switch (value__) {
    case MatchaPBUnderlineStyle_UndrelineStyleNone:
    case MatchaPBUnderlineStyle_UndrelineStyleSingle:
    case MatchaPBUnderlineStyle_UndrelineStyleDouble:
    case MatchaPBUnderlineStyle_UndrelineStyleThick:
    case MatchaPBUnderlineStyle_UndrelineStyleDotted:
    case MatchaPBUnderlineStyle_UndrelineStyleDashed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MatchaPBTextWrap

GPBEnumDescriptor *MatchaPBTextWrap_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TextWrapNone\000TextWrapWord\000TextWrapCharac"
        "ter\000";
    static const int32_t values[] = {
        MatchaPBTextWrap_TextWrapNone,
        MatchaPBTextWrap_TextWrapWord,
        MatchaPBTextWrap_TextWrapCharacter,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MatchaPBTextWrap)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MatchaPBTextWrap_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MatchaPBTextWrap_IsValidValue(int32_t value__) {
  switch (value__) {
    case MatchaPBTextWrap_TextWrapNone:
    case MatchaPBTextWrap_TextWrapWord:
    case MatchaPBTextWrap_TextWrapCharacter:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MatchaPBTruncation

GPBEnumDescriptor *MatchaPBTruncation_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TruncationNone\000TruncationStart\000Truncatio"
        "nMiddle\000TruncationEnd\000";
    static const int32_t values[] = {
        MatchaPBTruncation_TruncationNone,
        MatchaPBTruncation_TruncationStart,
        MatchaPBTruncation_TruncationMiddle,
        MatchaPBTruncation_TruncationEnd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MatchaPBTruncation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MatchaPBTruncation_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MatchaPBTruncation_IsValidValue(int32_t value__) {
  switch (value__) {
    case MatchaPBTruncation_TruncationNone:
    case MatchaPBTruncation_TruncationStart:
    case MatchaPBTruncation_TruncationMiddle:
    case MatchaPBTruncation_TruncationEnd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MatchaPBSizeFunc

@implementation MatchaPBSizeFunc

@dynamic hasText, text;
@dynamic hasMinSize, minSize;
@dynamic hasMaxSize, maxSize;

typedef struct MatchaPBSizeFunc__storage_ {
  uint32_t _has_storage_[1];
  MatchaPBStyledText *text;
  MatchaLayoutPBPoint *minSize;
  MatchaLayoutPBPoint *maxSize;
} MatchaPBSizeFunc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = GPBStringifySymbol(MatchaPBStyledText),
        .number = MatchaPBSizeFunc_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MatchaPBSizeFunc__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "minSize",
        .dataTypeSpecific.className = GPBStringifySymbol(MatchaLayoutPBPoint),
        .number = MatchaPBSizeFunc_FieldNumber_MinSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MatchaPBSizeFunc__storage_, minSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxSize",
        .dataTypeSpecific.className = GPBStringifySymbol(MatchaLayoutPBPoint),
        .number = MatchaPBSizeFunc_FieldNumber_MaxSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MatchaPBSizeFunc__storage_, maxSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MatchaPBSizeFunc class]
                                     rootClass:[MatchaPBTextRoot class]
                                          file:MatchaPBTextRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MatchaPBSizeFunc__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\007\000\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MatchaPBText

@implementation MatchaPBText

@dynamic text;

typedef struct MatchaPBText__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} MatchaPBText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBText_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MatchaPBText__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MatchaPBText class]
                                     rootClass:[MatchaPBTextRoot class]
                                          file:MatchaPBTextRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MatchaPBText__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MatchaPBStyledText

@implementation MatchaPBStyledText

@dynamic stylesArray, stylesArray_Count;
@dynamic hasText, text;

typedef struct MatchaPBStyledText__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *stylesArray;
  MatchaPBText *text;
} MatchaPBStyledText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stylesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MatchaPBTextStyle),
        .number = MatchaPBStyledText_FieldNumber_StylesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MatchaPBStyledText__storage_, stylesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = GPBStringifySymbol(MatchaPBText),
        .number = MatchaPBStyledText_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MatchaPBStyledText__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MatchaPBStyledText class]
                                     rootClass:[MatchaPBTextRoot class]
                                          file:MatchaPBTextRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MatchaPBStyledText__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MatchaPBFont

@implementation MatchaPBFont

@dynamic family;
@dynamic face;
@dynamic size;

typedef struct MatchaPBFont__storage_ {
  uint32_t _has_storage_[1];
  NSString *family;
  NSString *face;
  double size;
} MatchaPBFont__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "family",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBFont_FieldNumber_Family,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MatchaPBFont__storage_, family),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "face",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBFont_FieldNumber_Face,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MatchaPBFont__storage_, face),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBFont_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MatchaPBFont__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MatchaPBFont class]
                                     rootClass:[MatchaPBTextRoot class]
                                          file:MatchaPBTextRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MatchaPBFont__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MatchaPBTextStyle

@implementation MatchaPBTextStyle

@dynamic index;
@dynamic textAlignment;
@dynamic strikethroughStyle;
@dynamic hasStrikethroughColor;
@dynamic strikethroughColorRed;
@dynamic strikethroughColorGreen;
@dynamic strikethroughColorBlue;
@dynamic strikethroughColorAlpha;
@dynamic underlineStyle;
@dynamic hasUnderlineColor;
@dynamic underlineColorRed;
@dynamic underlineColorGreen;
@dynamic underlineColorBlue;
@dynamic underlineColorAlpha;
@dynamic hyphenation;
@dynamic lineHeightMultiple;
@dynamic maxLines;
@dynamic hasTextColor;
@dynamic textColorRed;
@dynamic textColorGreen;
@dynamic textColorBlue;
@dynamic textColorAlpha;
@dynamic wrap;
@dynamic truncation;
@dynamic truncationString;
@dynamic fontName;
@dynamic fontSize;

typedef struct MatchaPBTextStyle__storage_ {
  uint32_t _has_storage_[1];
  MatchaPBTextAlignment textAlignment;
  MatchaPBStrikethroughStyle strikethroughStyle;
  MatchaPBUnderlineStyle underlineStyle;
  MatchaPBTextWrap wrap;
  MatchaPBTruncation truncation;
  uint32_t strikethroughColorRed;
  uint32_t strikethroughColorGreen;
  uint32_t strikethroughColorBlue;
  uint32_t strikethroughColorAlpha;
  uint32_t underlineColorRed;
  uint32_t underlineColorGreen;
  uint32_t underlineColorBlue;
  uint32_t underlineColorAlpha;
  uint32_t textColorRed;
  uint32_t textColorGreen;
  uint32_t textColorBlue;
  uint32_t textColorAlpha;
  NSString *truncationString;
  NSString *fontName;
  int64_t index;
  double hyphenation;
  double lineHeightMultiple;
  int64_t maxLines;
  double fontSize;
} MatchaPBTextStyle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "textAlignment",
        .dataTypeSpecific.enumDescFunc = MatchaPBTextAlignment_EnumDescriptor,
        .number = MatchaPBTextStyle_FieldNumber_TextAlignment,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, textAlignment),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "strikethroughStyle",
        .dataTypeSpecific.enumDescFunc = MatchaPBStrikethroughStyle_EnumDescriptor,
        .number = MatchaPBTextStyle_FieldNumber_StrikethroughStyle,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, strikethroughStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "underlineStyle",
        .dataTypeSpecific.enumDescFunc = MatchaPBUnderlineStyle_EnumDescriptor,
        .number = MatchaPBTextStyle_FieldNumber_UnderlineStyle,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, underlineStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "hyphenation",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_Hyphenation,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, hyphenation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lineHeightMultiple",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_LineHeightMultiple,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, lineHeightMultiple),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maxLines",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_MaxLines,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, maxLines),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "wrap",
        .dataTypeSpecific.enumDescFunc = MatchaPBTextWrap_EnumDescriptor,
        .number = MatchaPBTextStyle_FieldNumber_Wrap,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, wrap),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "truncation",
        .dataTypeSpecific.enumDescFunc = MatchaPBTruncation_EnumDescriptor,
        .number = MatchaPBTextStyle_FieldNumber_Truncation,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, truncation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "truncationString",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_TruncationString,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, truncationString),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fontName",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_FontName,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, fontName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fontSize",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_FontSize,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, fontSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "hasStrikethroughColor",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_HasStrikethroughColor,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "strikethroughColorRed",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_StrikethroughColorRed,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, strikethroughColorRed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "strikethroughColorGreen",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_StrikethroughColorGreen,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, strikethroughColorGreen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "strikethroughColorBlue",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_StrikethroughColorBlue,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, strikethroughColorBlue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "strikethroughColorAlpha",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_StrikethroughColorAlpha,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, strikethroughColorAlpha),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hasUnderlineColor",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_HasUnderlineColor,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "underlineColorRed",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_UnderlineColorRed,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, underlineColorRed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "underlineColorGreen",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_UnderlineColorGreen,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, underlineColorGreen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "underlineColorBlue",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_UnderlineColorBlue,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, underlineColorBlue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "underlineColorAlpha",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_UnderlineColorAlpha,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, underlineColorAlpha),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hasTextColor",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_HasTextColor,
        .hasIndex = 19,
        .offset = 20,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "textColorRed",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_TextColorRed,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, textColorRed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "textColorGreen",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_TextColorGreen,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, textColorGreen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "textColorBlue",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_TextColorBlue,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, textColorBlue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "textColorAlpha",
        .dataTypeSpecific.className = NULL,
        .number = MatchaPBTextStyle_FieldNumber_TextColorAlpha,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(MatchaPBTextStyle__storage_, textColorAlpha),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MatchaPBTextStyle class]
                                     rootClass:[MatchaPBTextRoot class]
                                          file:MatchaPBTextRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MatchaPBTextStyle__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\027\002\r\000\004\022\000\010\016\000\020\022\000\022\010\000\032\020\000\033\010\000\035\010\000\037\025\000 \025\000!\027\000\"\026\000#\027\000"
        ")\021\000*\021\000+\023\000,\022\000-\023\0003\014\0004\014\0005\016\0006\r\0007\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MatchaPBTextStyle_TextAlignment_RawValue(MatchaPBTextStyle *message) {
  GPBDescriptor *descriptor = [MatchaPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MatchaPBTextStyle_FieldNumber_TextAlignment];
  return GPBGetMessageInt32Field(message, field);
}

void SetMatchaPBTextStyle_TextAlignment_RawValue(MatchaPBTextStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [MatchaPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MatchaPBTextStyle_FieldNumber_TextAlignment];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MatchaPBTextStyle_StrikethroughStyle_RawValue(MatchaPBTextStyle *message) {
  GPBDescriptor *descriptor = [MatchaPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MatchaPBTextStyle_FieldNumber_StrikethroughStyle];
  return GPBGetMessageInt32Field(message, field);
}

void SetMatchaPBTextStyle_StrikethroughStyle_RawValue(MatchaPBTextStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [MatchaPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MatchaPBTextStyle_FieldNumber_StrikethroughStyle];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MatchaPBTextStyle_UnderlineStyle_RawValue(MatchaPBTextStyle *message) {
  GPBDescriptor *descriptor = [MatchaPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MatchaPBTextStyle_FieldNumber_UnderlineStyle];
  return GPBGetMessageInt32Field(message, field);
}

void SetMatchaPBTextStyle_UnderlineStyle_RawValue(MatchaPBTextStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [MatchaPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MatchaPBTextStyle_FieldNumber_UnderlineStyle];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MatchaPBTextStyle_Wrap_RawValue(MatchaPBTextStyle *message) {
  GPBDescriptor *descriptor = [MatchaPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MatchaPBTextStyle_FieldNumber_Wrap];
  return GPBGetMessageInt32Field(message, field);
}

void SetMatchaPBTextStyle_Wrap_RawValue(MatchaPBTextStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [MatchaPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MatchaPBTextStyle_FieldNumber_Wrap];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MatchaPBTextStyle_Truncation_RawValue(MatchaPBTextStyle *message) {
  GPBDescriptor *descriptor = [MatchaPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MatchaPBTextStyle_FieldNumber_Truncation];
  return GPBGetMessageInt32Field(message, field);
}

void SetMatchaPBTextStyle_Truncation_RawValue(MatchaPBTextStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [MatchaPBTextStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MatchaPBTextStyle_FieldNumber_Truncation];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
